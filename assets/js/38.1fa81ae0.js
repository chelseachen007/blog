(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{407:function(a,t,e){"use strict";e.r(t);var s=e(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"http-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[a._v("#")]),a._v(" HTTP 缓存")]),a._v(" "),e("p",[a._v("HTTP 缓存对性能优化的重要性不言而喻，只要命中缓存就不需要重新加载一遍文件，js 执行时间相比下载时间要快的多，如果能优化下载时间，用户体验会提升很多")]),a._v(" "),e("p",[a._v("HTTP 缓存可以分为：")]),a._v(" "),e("ol",[e("li",[a._v("强缓存")]),a._v(" "),e("li",[a._v("协商缓存")])]),a._v(" "),e("h2",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),e("p",[a._v("强缓存优先级较高，HTTP 会优先判断是否命中强缓存。那么 HTTP 是怎么判断的呢。")]),a._v(" "),e("p",[a._v("强缓存是利用 HTTP 头中的 "),e("code",[a._v("Expires")]),a._v(" 和 "),e("code",[a._v("Cache-Control")]),a._v(" 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 "),e("code",[a._v("expires")]),a._v(" 和 "),e("code",[a._v("cache-control")]),a._v(" 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，"),e("strong",[a._v("不会再与服务端发生通信")]),a._v("。")]),a._v(" "),e("h3",{attrs:{id:"expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Expires")]),a._v("\n expires"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Wed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),a._v(" Sep "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2019")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("18")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),e("p",[e("code",[a._v("expires")]),a._v(" 是一个时间戳 通过对比时间戳来决定是否命中强缓存\n但 "),e("code",[a._v("expires")]),a._v(" 是有问题的，它最大的问题在于对“"),e("strong",[a._v("本地时间")]),a._v("”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 "),e("code",[a._v("expires")]),a._v(" 将无法达到我们的预期。")]),a._v(" "),e("h3",{attrs:{id:"cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Cache-Control")]),a._v("\n Cache"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("max"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("age"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v("\n")])])]),e("p",[a._v("HTTP1.1 新增了 "),e("strong",[a._v("Cache-Control")]),a._v("\n在 Cache-Control 中，我们通过 max-age 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("max-age")]),a._v("：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效")]),a._v(" "),e("li",[e("strong",[a._v("no-cache")]),a._v("：不使用强缓存，需要与服务器验证缓存是否新鲜")]),a._v(" "),e("li",[e("strong",[a._v("no-store")]),a._v("：顾名思义就是不使用任何缓存策略。每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。")]),a._v(" "),e("li",[e("strong",[a._v("private")]),a._v("：专用于个人的缓存，中间代理、CDN 等不能缓存此响应")]),a._v(" "),e("li",[e("strong",[a._v("public")]),a._v("：响应可以被中间代理、CDN 等缓存")]),a._v(" "),e("li",[e("strong",[a._v("must-revalidate")]),a._v("：只要过期就必须回源服务器验证，")]),a._v(" "),e("li",[e("strong",[a._v("proxy-revalidate")]),a._v("：只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了")]),a._v(" "),e("li",[e("strong",[a._v("s-maxage")]),a._v(" :限定在代理上能够存多久")]),a._v(" "),e("li",[e("strong",[a._v("no-transform")]),a._v("：代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理。 "),e("code",[a._v("no-transform")]),a._v(" 就会禁止这样做")])]),a._v(" "),e("h3",{attrs:{id:"pragma"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pragma"}},[a._v("#")]),a._v(" Pragma")]),a._v(" "),e("p",[a._v("Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。")]),a._v(" "),e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),e("p",[a._v("当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 "),e("code",[a._v("If-Modified-Since")]),a._v(" 或者 "),e("code",[a._v("If-None-Match")]),a._v(" 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 "),e("code",[a._v("Last-Modified")]),a._v(" 或者 "),e("code",[a._v("ETag")]),a._v(" 属性。")]),a._v(" "),e("h3",{attrs:{id:"last-modified-if-modified-since"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[a._v("#")]),a._v(" Last-Modified/If-Modified-Since")]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//client")]),a._v("\nIf"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Modified"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Since"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Fri"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(" Oct "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2017")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("06")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("35")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("57")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Server")]),a._v("\nLast"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Modified"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Fri"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(" Oct "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2017")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("06")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("35")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("57")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),e("p",[a._v("即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。")]),a._v(" "),e("p",[a._v("第二次发起请求的时候，请求头会带上上一次响应头中的 "),e("code",[a._v("Last-Modified")]),a._v(" 的时间，并放到 "),e("code",[a._v("If-Modified-Since")]),a._v(" 请求头属性中，服务端根据文件最后一次修改时间和 "),e("code",[a._v("If-Modified-Since")]),a._v(" 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。")]),a._v(" "),e("p",[a._v("缺点：")]),a._v(" "),e("ul",[e("li",[a._v("由于 Last-Modified 修改时间是 GMT 时间，只能精确到秒，如果文件在 1 秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件")]),a._v(" "),e("li",[a._v("如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。")])]),a._v(" "),e("h3",{attrs:{id:"etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" ETag")]),a._v(" "),e("p",[e("code",[a._v("ETag")]),a._v(" 就是为了解决 "),e("code",[a._v("Last-Modified")]),a._v(" 无法解决高频修改文件缓存问题，可以称他为 "),e("strong",[a._v("文件指纹")]),a._v("。")]),a._v(" "),e("p",[e("code",[a._v("Etag")]),a._v(" 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 "),e("code",[a._v("Etag")]),a._v(" 就是不同的，反之亦然。因此 "),e("code",[a._v("Etag")]),a._v(" 能够精准地感知文件的变化。")]),a._v(" "),e("p",[a._v("ETag 还有"),e("code",[a._v("强")]),a._v(" 、"),e("code",[a._v("弱")]),a._v("之分。")]),a._v(" "),e("p",[e("code",[a._v("强 ETag")]),a._v(" 要求资源在字节级别必须完全相符，"),e("code",[a._v("弱 ETag")]),a._v(" 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。")]),a._v(" "),e("p",[a._v("缺点：")]),a._v(" "),e("ul",[e("li",[a._v("显而易见， "),e("code",[a._v("ETag")]),a._v("需要去检查文件字节变化，然后生成 hash 字符串，增加了运算成本。")])]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//client")]),a._v("\nIf"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("None"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Match"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("W")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"2a3b-1602480f459"')]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Server")]),a._v("\nETag"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("W")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"2a3b-1602480f459"')]),a._v("\n")])])]),e("p",[e("strong",[a._v("Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。")])]),a._v(" "),e("h2",{attrs:{id:"整体流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整体流程"}},[a._v("#")]),a._v(" 整体流程")]),a._v(" "),e("img",{attrs:{src:"https://i.loli.net/2021/03/02/3kiNc4vJP1aTdmR.png",alt:"缓存顺序"}}),a._v(" "),e("p",[a._v("当浏览器再次访问一个已经访问过的资源时，它会这样做：")]),a._v(" "),e("ol",[e("li",[a._v("看看是否命中强缓存，如果命中，就直接使用缓存了。（express 和 Cache-Control:max-age）")]),a._v(" "),e("li",[a._v("如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。（if-last-modify 和 Etag）")]),a._v(" "),e("li",[a._v("如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。")]),a._v(" "),e("li",[a._v("否则，返回最新的资源。")])]),a._v(" "),e("h2",{attrs:{id:"缓存位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),e("p",[a._v("当强缓存命中或者协商缓存中服务器返回 304 的时候，会从本地取，那么本地缓存在哪里呢")]),a._v(" "),e("p",[a._v("浏览器中的缓存位置有以下 4 种，按优先级分别是：")]),a._v(" "),e("ul",[e("li",[a._v("Service Worker")]),a._v(" "),e("li",[a._v("Memory Cache")]),a._v(" "),e("li",[a._v("Disk Cache")]),a._v(" "),e("li",[a._v("Push Cache")])]),a._v(" "),e("h3",{attrs:{id:"service-worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),e("p",[a._v("Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现"),e("code",[a._v("离线缓存")]),a._v("、"),e("code",[a._v("消息推送")]),a._v("和"),e("code",[a._v("网络代理")]),a._v("等功能。其中的离线缓存就是 "),e("code",[a._v("Service Worker Cache")]),a._v("。"),e("code",[a._v("Service Worker")]),a._v(" 同时也是 "),e("code",[a._v("PWA")]),a._v(" 的重要实现机制")]),a._v(" "),e("p",[a._v("PS：大家注意 Server Worker 对协议是有要求的，必须以 "),e("strong",[a._v("https")]),a._v(" 协议为前提。")]),a._v(" "),e("h3",{attrs:{id:"memory-cache-和-disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache"}},[a._v("#")]),a._v(" Memory Cache 和 Disk Cache")]),a._v(" "),e("p",[e("code",[a._v("Memory Cache")]),a._v(" 顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。\n"),e("code",[a._v("Disk Cache")]),a._v(" 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 "),e("code",[a._v("Memory Cache")]),a._v(" 胜在容量和存储时效性上。")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("---")]),a._v(" "),e("th",[a._v("memory cache")]),a._v(" "),e("th",[a._v("disk cache")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("相同点")]),a._v(" "),e("td",[a._v("只能存储一些派生类资源文件")]),a._v(" "),e("td",[a._v("只能存储一些派生类资源文件")])]),a._v(" "),e("tr",[e("td",[a._v("不同点")]),a._v(" "),e("td",[a._v("退出进程时数据会被清除")]),a._v(" "),e("td",[a._v("退出进程时数据不会被清除")])]),a._v(" "),e("tr",[e("td",[a._v("存储资源-scale")]),a._v(" "),e("td",[a._v("一般脚本、字体、图片会存在内存当中")]),a._v(" "),e("td",[a._v("般非脚本会存在内存当中，如 css 等")])])])]),a._v(" "),e("ul",[e("li",[a._v("比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存")]),a._v(" "),e("li",[a._v("内存使用率比较高的时候，文件优先进入磁盘")])]),a._v(" "),e("h3",{attrs:{id:"push-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),e("p",[e("code",[a._v("推送缓存")]),a._v(" 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。")]),a._v(" "),e("h2",{attrs:{id:"用户操作对缓存的影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户操作对缓存的影响"}},[a._v("#")]),a._v(" 用户操作对缓存的影响")]),a._v(" "),e("h3",{attrs:{id:"地址栏输入地址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#地址栏输入地址"}},[a._v("#")]),a._v(" 地址栏输入地址")]),a._v(" "),e("p",[a._v("优先查找"),e("code",[a._v("Disk Cache")]),a._v("看是否有匹配，没有则发送网络请求")]),a._v(" "),e("h3",{attrs:{id:"f5-刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#f5-刷新"}},[a._v("#")]),a._v(" F5 刷新")]),a._v(" "),e("p",[a._v("优先查找 "),e("code",[a._v("Memory Cache")]),a._v(" 然后再去匹配 "),e("code",[a._v("Disk Cache")]),a._v("。不走强缓存但是")]),a._v(" "),e("h3",{attrs:{id:"ctrl-f5-刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ctrl-f5-刷新"}},[a._v("#")]),a._v(" CTRL+F5 刷新")]),a._v(" "),e("p",[a._v("不使用缓存")]),a._v(" "),e("h2",{attrs:{id:"缓存场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存场景"}},[a._v("#")]),a._v(" 缓存场景")]),a._v(" "),e("p",[a._v("对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略")]),a._v(" "),e("p",[a._v("对于"),e("strong",[a._v("某些不需要缓存的资源")]),a._v("，可以使用 Cache-control: "),e("strong",[a._v("no-store")]),a._v(" ，表示该资源不需要缓存\n对于"),e("strong",[a._v("频繁变动的资源")]),a._v("，可以使用 Cache-Control: "),e("strong",[a._v("no-cache 并配合 ETag 使用")]),a._v("，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新\n对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),e("p",[e("a",{attrs:{href:"http://47.98.159.95/my_blog/perform/001.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[a._v("《前端性能相关》"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5eb7f811f265da7bbc7cc5bd",target:"_blank",rel:"noopener noreferrer"}},[a._v("《图解 HTTP 缓存》"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5b70edd4f265da27df0938bc#heading-7",target:"_blank",rel:"noopener noreferrer"}},[a._v("《前端也要懂的 HTTP 缓存》"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000020086923",target:"_blank",rel:"noopener noreferrer"}},[a._v("《HTTP 缓存和浏览器的本地存储》"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);