(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{399:function(t,a,e){"use strict";e.r(a);var s=e(45),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"docker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker"}},[t._v("#")]),t._v(" Docker")]),t._v(" "),e("h2",{attrs:{id:"docker-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-简介"}},[t._v("#")]),t._v(" Docker 简介")]),t._v(" "),e("h3",{attrs:{id:"docker-镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-镜像"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Docker 镜像")])]),t._v(" "),e("p",[t._v("是一种 UnionFS（联合文件系统），是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下.")]),t._v(" "),e("p",[t._v("镜像同时也很小，因为我们 pull 的镜像剔除了无用的东西，只是一个精简功能版的镜像")]),t._v(" "),e("p",[t._v("下载是一层一层下载，这样便于共享资源。")]),t._v(" "),e("h3",{attrs:{id:"docker-容器数据卷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器数据卷"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Docker 容器数据卷")])]),t._v(" "),e("p",[t._v("卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续存储或共享数据的特性，卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。")]),t._v(" "),e("p",[t._v("dockerfile 也就是添加 容器数据卷的一种方式")]),t._v(" "),e("h3",{attrs:{id:"dockerfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile"}},[t._v("#")]),t._v(" dockerfile")]),t._v(" "),e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#基础镜像，当前新镜像是基于哪个镜像的")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MAINTAINER")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#镜像维护者的姓名和邮箱地址")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("RUN")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#容器构建时需要运行的命令")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXPOSE")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#当前容器对外暴露出的端口")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WORKDIR")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#指定在创建容器后，终端默认登陆的进来工作目录")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENV")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#用来在构建镜像过程中设置环境变量")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ADD")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COPY")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VOLUME")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#容器数据卷，用于数据保存和持久化工作")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CMD")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#指定一个容器启动时要运行的命令，Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENTRYPOINT")]),t._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#指定一个容器启动时要运行的命令，ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ONBUILD")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发")]),t._v("\n")])])]),e("p",[t._v("例：")]),t._v(" "),e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#Dockerfile")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#制定node镜像的版本")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("10"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("alpine\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#移动当前目录下面的文件到app目录下")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ADD")]),t._v(" . /app/\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#进入到app目录下面，类似cd")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WORKDIR")]),t._v(" /app\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#安装依赖")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("RUN")]),t._v(" npm install\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#对外暴露的端口")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXPOSE")]),t._v(" 3000\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#程序启动脚本")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CMD")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"node"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"app.js"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("h3",{attrs:{id:"优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[t._v("#")]),t._v(" 优势")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[e("strong",[t._v("特性")])]),t._v(" "),e("th",[e("strong",[t._v("容器")])]),t._v(" "),e("th",[e("strong",[t._v("虚拟机")])])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("启动")]),t._v(" "),e("td",[t._v("秒级")]),t._v(" "),e("td",[t._v("分钟级")])]),t._v(" "),e("tr",[e("td",[t._v("硬盘使用")]),t._v(" "),e("td",[t._v("一般为 MB")]),t._v(" "),e("td",[t._v("一般为 GB")])]),t._v(" "),e("tr",[e("td",[t._v("性能")]),t._v(" "),e("td",[t._v("接近原生")]),t._v(" "),e("td",[t._v("弱于")])]),t._v(" "),e("tr",[e("td",[t._v("系统支持量")]),t._v(" "),e("td",[t._v("单机支持上千个容器")]),t._v(" "),e("td",[t._v("一般几十个")])])])]),t._v(" "),e("h2",{attrs:{id:"流程整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流程整理"}},[t._v("#")]),t._v(" 流程整理")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker search nginx\ndocker pull nginx\ndocker images\ndocker run -it -p 8080:8080 nginx\ndocker ps\ndocker stop ff6\n")])])]),e("h2",{attrs:{id:"docker-安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-安装"}},[t._v("#")]),t._v(" Docker 安装")]),t._v(" "),e("div",{staticClass:"language-JavaScript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[t._v("# apt升级\nsudo apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" update\n\n# 添加相关软件包\napt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" install apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("transport"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("https\napt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" install ca"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("certificates curl software"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("properties"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("common\n\n# 下载软件包的合法性，需要添加软件源的 "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GPG")]),t._v(" 密钥\ncurl "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("fsSL https"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("mirrors"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ustc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("edu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cn"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("docker"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("ce"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("linux"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ubuntu"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("gpg "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" sudo apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key add\n\n# source"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list 中添加 Docker 软件源\nsudo add"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v('repository\n"deb '),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("arch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("amd64"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" https"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("mirrors"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ustc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("edu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cn"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("docker"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("ce"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("linux"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ubuntu  \n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lsb_release "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("cs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v('   \nstable"\n\n# 安装 Docker '),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CE")]),t._v("\nsudo apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" update\nsudo apt"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" install docker"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("ce\n\n# Helloworld测试\ndocker run hello"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("world\n\n")])])]),e("h3",{attrs:{id:"安装-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装-node"}},[t._v("#")]),t._v(" 安装 node")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 安装nvm\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n\n# 将nvm作为环境变量\nexport NVM_DIR="$HOME/.nvm"\n[ -s "$NVM_DIR/nvm.sh" ] && \\. "$NVM_DIR/nvm.sh"  # This loads nvm\n[ -s "$NVM_DIR/bash_completion" ] && \\. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion\n\n#安装最新版 node\nnvm install node\n\n#安装pm2\nnpm i pm2 -g\n')])])]),e("h3",{attrs:{id:"自动化部署-ci-cd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动化部署-ci-cd"}},[t._v("#")]),t._v(" 自动化部署 CI/CD")]),t._v(" "),e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# dockerfile")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# build stage")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("lts"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("alpine as build"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("stage\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WORKDIR")]),t._v(" /app\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COPY")]),t._v(" package*.json ./\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("RUN")]),t._v(" npm install\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COPY")]),t._v(" . .\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("RUN")]),t._v(" npm run build\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# production stage")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" nginx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("stable"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("alpine as production"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("stage\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COPY")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("from=build"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("stage /app/dist /usr/share/nginx/html\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXPOSE")]),t._v(" 80\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CMD")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nginx"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-g"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"daemon off;"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("逐行解析配置：")]),t._v(" "),e("ul",[e("li",[t._v("FROM node:lts-alpine as build-stage：基于 node "),e("code",[t._v("lts-alpine")]),t._v(" 版本镜像，并通过构建阶段命名，将有 node 环境的阶段命名为 "),e("code",[t._v("build-stage")]),t._v("（包含 alpine 的镜像版本相比于 latest 版本更加小巧，更适合作为 docker 镜像使用）")]),t._v(" "),e("li",[t._v("WORKDIR /app：将工作区设为 /app，和其他系统文件隔离")]),t._v(" "),e("li",[t._v("COPY package*.json ./：拷贝 package.json/package-lock.json 到容器的 /app 目录")]),t._v(" "),e("li",[t._v("RUN npm install：运行 "),e("code",[t._v("npm install")]),t._v(" 在容器中安装依赖")]),t._v(" "),e("li",[t._v("COPY . .：拷贝其他文件到容器 /app 目录，分两次拷贝是因为保持 node_modules 一致")]),t._v(" "),e("li",[t._v("RUN npm run build：运行 "),e("code",[t._v("npm run build")]),t._v(" 在容器中构建")])]),t._v(" "),e("h2",{attrs:{id:"docker-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-优化"}},[t._v("#")]),t._v(" docker 优化")]),t._v(" "),e("h3",{attrs:{id:"利用镜像缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#利用镜像缓存"}},[t._v("#")]),t._v(" 利用镜像缓存")]),t._v(" "),e("p",[t._v("相对于项目的源文件来讲，"),e("code",[t._v("package.json")]),t._v(" 是相对稳定的。如果没有新的安装包需要下载，则再次构建镜像时，无需重新构建依赖。则可以在 npm install 上节省一半的时间。")]),t._v(" "),e("p",[t._v("对于 "),e("code",[t._v("ADD")]),t._v(" 来讲，如果需要添加的文件内容的 "),e("code",[t._v("checksum")]),t._v(" 没有发生变化，则可以利用缓存。把 "),e("code",[t._v("package.json/package-lock.json")]),t._v(" 与源文件分隔开写入镜像是一个很好的选择。目前，如果没有新的安装包更新的话，可以节省一半时间")]),t._v(" "),e("div",{staticClass:"language-dockerfile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 首次添加此两个文件，充分利用缓存")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ADD")]),t._v(" package.json package"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("lock.json /code\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("RUN")]),t._v(" npm install "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("production\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),e("h3",{attrs:{id:"减少-npm-install-时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少-npm-install-时间"}},[t._v("#")]),t._v(" 减少 npm install 时间")]),t._v(" "),e("ol",[e("li",[t._v("选择时延低的 "),e("code",[t._v("registry")]),t._v("，需要企业技术基础建设支持")])]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("npm config set registry https://registry-npm.shanyue.tech/\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[t._v("NODE_ENV=production")]),t._v("，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)")]),t._v(" "),e("li",[e("code",[t._v("CI=true")]),t._v("，npm 会在此环境变量下自动优化")]),t._v(" "),e("li",[t._v("结合 CI 的缓存功能，充分利用 "),e("code",[t._v("npm cache")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("install")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" npm ci\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# keep the npm cache around to speed up installs")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("cache")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("directories")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$HOME/.npm"')]),t._v("\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("使用 "),e("code",[t._v("npm ci")]),t._v(" 代替 "),e("code",[t._v("npm i")]),t._v("，既提升速度又保障应用安全性")])]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" ci\n")])])]),e("h3",{attrs:{id:"多阶段构建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多阶段构建"}},[t._v("#")]),t._v(" 多阶段构建")]),t._v(" "),e("p",[t._v("得益于缓存，现在镜像构建时间已经快了不少。但是，此时镜像的体积依旧过于庞大，这也将会导致部署时间的加长。原因如下")]),t._v(" "),e("p",[t._v("考虑下每次 CI/CD 部署的流程")]),t._v(" "),e("ol",[e("li",[t._v("在构建服务器 (Runer) 构建镜像")]),t._v(" "),e("li",[t._v("把镜像推至镜像仓库服务器")]),t._v(" "),e("li",[t._v("在生产服务器拉取镜像，启动容器")])]),t._v(" "),e("h2",{attrs:{id:"docker-compose"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose"}},[t._v("#")]),t._v(" Docker Compose")]),t._v(" "),e("p",[t._v("Docker Compose 是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。")]),t._v(" "),e("p",[t._v("使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("version")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"3.1"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("services")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("nginx")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("restart")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" always\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#　image是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 8091"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用[HOST:CONTAINER:ro]格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ./nginx/conf.d/"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/etc/nginx/conf.d\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ./frontend/dist/"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/var/www/html/\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ./static/"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/static/\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app-pm2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("container_name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" app"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("pm2\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#构建容器")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("build")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ./backend\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"3000:3000"')]),t._v("\n")])])]),e("h3",{attrs:{id:"启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动"}},[t._v("#")]),t._v(" 启动")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker-compose up\n// or\ndocker-compose up -d\n")])])]),e("h2",{attrs:{id:"配置镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置镜像"}},[t._v("#")]),t._v(" 配置镜像")]),t._v(" "),e("div",{staticClass:"language-JavaScripton extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('{\n  "registry-mirrors": [\n"https://registry.docker-cn.com",\n"http://hub-mirror.c.163.com",\n"https://docker.mirrors.ustc.edu.cn",\n"http://dockerhub.azk8s.cn/" ],\n  "insecure-registries": [],\n  "debug": true,\n  "experimental": false\n}\n')])])]),e("h2",{attrs:{id:"docker-常用命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-常用命令"}},[t._v("#")]),t._v(" docker 常用命令")]),t._v(" "),e("h3",{attrs:{id:"镜像命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#镜像命令"}},[t._v("#")]),t._v(" 镜像命令")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker images                    #查看当前Docker中的镜像\ndocker search 某个镜像名字                #查询某个镜像\ndocker pull 某个镜像名字                #拉取(下载)某个镜像\ndocker rmi 某个镜像名字ID                 #删除某个镜像\n")])])]),e("h3",{attrs:{id:"容器基本命令-切记-有镜像才能创建容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器基本命令-切记-有镜像才能创建容器"}},[t._v("#")]),t._v(" 容器基本命令(切记，有镜像才能创建容器)")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker run [OPTIONS] image [COMMAND] [ARG...]   #新建并启动容器\ndocker ps [OPTIONS]                             #列出当前所有正在运行的容器\nexit                        #容器停止退出\nctrl+P+Q                    #容器不停止退出\ndocker start 容器ID或者容器名            #启动容器\ndocker restart 容器ID或者容器名            #重启容器\ndocker stop 容器ID或者容器名            #停止容器\ndocker kill 容器ID或者容器名            #强制停止容器\ndocker rm 容器ID                    #删除已停止的容器\ndocker rm -f $(docker ps -a -q)            #一次性删除多个容器\ndocker ps -a -q | xargs docker rm        #一次性删除多个容器\n")])])]),e("h3",{attrs:{id:"容器重要命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器重要命令"}},[t._v("#")]),t._v(" "),e("strong",[t._v("容器重要命令")])]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker run -d 容器名                #启动守护式容器\ndocker logs -f -t --tail 容器ID            #查看容器日志,-t是加入时间戳，-f是最新的日志打印,--tail数字显示最后多少条\n\ndocker top 容器ID                #查看容器内运行的进程\ndocker inspect 容器ID                #查看容器内部细节\ndocker exec -it 容器ID bashShell            #进入正在运行的容器并以命令行交互\ndocker attach 容器ID                #重新进入Docker容器\ndocker cp  容器ID:容器内路径 目的主机路径        #从容器内拷贝文件到主机上\n")])])]),e("h2",{attrs:{id:"docker-命令帮助"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-命令帮助"}},[t._v("#")]),t._v(" docker 命令帮助")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Commands:\n    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\n    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\n    commit    Create a new image from a container's changes # 提交当前容器为新的镜像\n    cp        Copy files/folders from the containers filesystem to the host path\n              # 从容器中拷贝指定文件或者目录到宿主机中\n    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\n    diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化\n    events    Get real time events from the server          # 从 docker 服务获取容器实时事件\n    exec      Run a command in an existing container        # 在已存在的容器上运行命令\n    export    Stream the contents of a container as a tar archive\n              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n    history   Show the history of an image                  # 展示一个镜像形成历史\n    images    List images                                   # 列出系统当前镜像\n    import    Create a new filesystem image from the contents of a tarball\n              # 从tar包中的内容创建一个新的文件系统映像[对应 export]\n    info      Display system-wide information               # 显示系统相关信息\n    inspect   Return low-level information on a container   # 查看容器详细信息\n    kill      Kill a running container                      # kill 指定 docker 容器\n    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\n    login     Register or Login to the docker registry server\n              # 注册或者登陆一个 docker 源服务器\n    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出\n    logs      Fetch the logs of a container                 # 输出当前容器日志信息\n    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT\n              # 查看映射端口对应的容器内部源端口\n    pause     Pause all processes within a container        # 暂停容器\n    ps        List containers                               # 列出容器列表\n    pull      Pull an image or a repository from the docker registry server\n              # 从docker镜像源服务器拉取指定镜像或者库镜像\n    push      Push an image or a repository to the docker registry server\n              # 推送指定镜像或者库镜像至docker源服务器\n    restart   Restart a running container                   # 重启运行的容器\n    rm        Remove one or more containers                 # 移除一个或者多个容器\n    rmi       Remove one or more images\n              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n    run       Run a command in a new container\n              # 创建一个新的容器并运行一个命令\n    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]\n    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\n    start     Start a stopped containers                    # 启动容器\n    stop      Stop a running containers                     # 停止容器\n    tag       Tag an image into a repository                # 给源中镜像打标签\n    top       Lookup the running processes of a container   # 查看容器中运行的进程信息\n    unpause   Unpause a paused container                    # 取消暂停容器\n    version   Show the docker version information           # 查看 docker 版本号\n    wait      Block until a container stops, then print its exit code\n              # 截取容器停止时的退出状态值\nRun 'docker COMMAND --help' for more information on a command.\n")])])]),e("h2",{attrs:{id:"docker-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-options"}},[t._v("#")]),t._v(" docker options")]),t._v(" "),e("div",{staticClass:"language-cmd extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Usage of docker:\n  --api-enable-cors=false                Enable CORS headers in the remote API                      # 远程 API 中开启 CORS 头\n  -b, --bridge=""                        Attach containers to a pre-existing network bridge         # 桥接网络\n                                           use \'none\' to disable container networking\n  --bip=""                               Use this CIDR notation address for the network bridge\'s IP, not compatible with -b\n                                         # 和 -b 选项不兼容，具体没有测试过\n  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式\n  -D, --debug=false                      Enable debug mode                                          # debug 模式\n  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器\n  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域\n  -e, --exec-driver="native"             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器\n  --fixed-cidr=""                        IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)\n                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)\n  -G, --group="docker"                   Group to assign the unix socket specified by -H when running in daemon mode\n                                           use \'\' (the empty string) to disable setting of a group\n  -g, --graph="/var/lib/docker"          Path to use as the root of the docker runtime              # 容器运行的根目录路径\n  -H, --host=[]                          The socket(s) to bind to in daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]\n                                           specified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.\n  --icc=true                             Enable inter-container communication                       # 跨容器通信\n  --insecure-registry=[]                 Enable insecure communication with specified registries (no certificate verification for HTTPS and enable HTTP fallback) (e.g., localhost:5000 or 10.20.0.0/16)\n  --ip="0.0.0.0"                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip\n  --ip-forward=true                      Enable net.ipv4.ip_forward                                 # 开启转发\n  --ip-masq=true                         Enable IP masquerading for bridge\'s IP range\n  --iptables=true                        Enable Docker\'s addition of iptables rules                 # 添加对应 iptables 规则\n  --mtu=0                                Set the containers network MTU                             # 设置网络 mtu\n                                           if no value is provided: default to the default route MTU or 1500 if no default route is available\n  -p, --pidfile="/var/run/docker.pid"    Path to use for daemon PID file                            # 指定 pid 文件位置\n  --registry-mirror=[]                   Specify a preferred Docker registry mirror\n  -s, --storage-driver=""                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动\n  --selinux-enabled=false                Enable selinux support                                     # 开启 selinux 支持\n  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项\n  --tls=false                            Use TLS; implied by tls-verify flags                       # 开启 tls\n  --tlscacert="/root/.docker/ca.pem"     Trust only remotes providing a certificate signed by the CA given here\n  --tlscert="/root/.docker/cert.pem"     Path to TLS certificate file                               # tls 证书文件位置\n  --tlskey="/root/.docker/key.pem"       Path to TLS key file                                       # tls key 文件位置\n  --tlsverify=false                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机\n  -v, --version=false                    Print version information and quit                         # 输出 docker 版本信息\n')])])])])}),[],!1,null,null,null);a.default=n.exports}}]);