(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{478:function(e,t,n){"use strict";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"【day-12】-lru-缓存机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#【day-12】-lru-缓存机制"}},[e._v("#")]),e._v(" 【Day 12】 LRU 缓存机制")]),e._v(" "),n("h2",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),n("div",{staticClass:"language-markdown extra-class"},[n("pre",{pre:!0,attrs:{class:"language-markdown"}},[n("code",[e._v("运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n进阶:\n\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n示例:\n\nLRUCache cache = new LRUCache( 2 /"),n("span",{pre:!0,attrs:{class:"token italic"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("_")]),n("span",{pre:!0,attrs:{class:"token content"}},[e._v(" 缓存容量 ")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("_")])]),e._v("/ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1); // 返回 1\ncache.put(3, 3); // 该操作会使得关键字 2 作废\ncache.get(2); // 返回 -1 (未找到)\ncache.put(4, 4); // 该操作会使得关键字 1 作废\ncache.get(1); // 返回 -1 (未找到)\ncache.get(3); // 返回 3\ncache.get(4); // 返回 4\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/lru-cache\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n")])])]),n("h2",{attrs:{id:"我的回答"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#我的回答"}},[e._v("#")]),e._v(" 我的回答")]),e._v(" "),n("h3",{attrs:{id:"解法一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解法一"}},[e._v("#")]),e._v(" 解法一")]),e._v(" "),n("h4",{attrs:{id:"时空复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#时空复杂度"}},[e._v("#")]),e._v(" 时空复杂度")]),e._v(" "),n("div",{staticClass:"language-JavaScript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[e._v("\n")])])]),n("h2",{attrs:{id:"参考回答"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考回答"}},[e._v("#")]),e._v(" 参考回答")]),e._v(" "),n("blockquote",[n("p",[e._v("确定需要使用的数据结构")]),e._v(" "),n("p",[e._v("根据题目要求,存储的数据需要保证顺序关系(逻辑层面) ===> 可以使用数组,链表等\n同时需要对数据进行频繁的增删, 时间复杂度 O(1) ===> 只能使用链表存储数据\n对数据进行读取时, 时间复杂度 O(1) ===> 使用哈希表\n最终采取双向链表 + 哈希表\n双向链表")]),e._v(" "),n("p",[e._v("按最后一次访问的时间的顺序进行排列, 链表头部为最近访问的节点")]),e._v(" "),n("p",[e._v("哈希表")]),e._v(" "),n("p",[e._v("以关键字为键,以链表节点的地址为值")]),e._v(" "),n("p",[e._v("put 操作\n通过哈希表, 查看 put 操作传入的关键字对应的链表节点, 是否已经存在\n如果已经存在,将该节点的值进行覆盖,同时将该节点位置调整至链表头部\n如果不存在,查看当前链表容量是否已满")]),e._v(" "),n("p",[e._v("如果链表容量未满, 新生成节点, 同时将该节点位置调整至链表头部\n如果链表容量已满, 删除尾部节点,新生成节点, 同时将该节点位置调整至链表头部")]),e._v(" "),n("p",[e._v("get 操作\n通过哈希表, 查看 get 操作传入的关键字对应的链表节点, 是否已经存在\n存在, 返回该节点的值, 同时将该节点位置调整至链表头部\n不存在, 返回-1")]),e._v(" "),n("p",[e._v("function ListNode(key, val) {\nthis.key = key\nthis.val = val;\nthis.pre = this.next = null;\n}")]),e._v(" "),n("p",[e._v("var LRUCache = function(capacity) {\nthis.capacity = capacity\nthis.size = 0\nthis.data = {}\nthis.head = new ListNode()\nthis.tail = new ListNode()\nthis.head.next = this.tail\nthis.tail.pre = this.head\n};")]),e._v(" "),n("p",[e._v("function get (key) {\nif(this.data[key] !== undefined){\nlet node = this.data[key]\nthis.removeNode(node)\nthis.appendHead(node)\nreturn node.val\n} else {\nreturn -1\n}\n};")]),e._v(" "),n("p",[e._v("function put (key, value) {\nlet node\nif(this.data[key] !== undefined){\nnode = this.data[key]\nthis.removeNode(node)\nnode.val = value\n} else {\nnode = new ListNode(key, value)\nthis.data[key] = node\nif(this.size < this.capacity){\nthis.size++\n} else {\nkey = this.removeTail()\ndelete this.data[key]\n}\n}\nthis.appendHead(node)\n};")]),e._v(" "),n("p",[e._v("function removeNode (node) {\nlet preNode = node.pre,\nnextNode = node.next\npreNode.next = nextNode\nnextNode.pre = preNode\n};")]),e._v(" "),n("p",[e._v("function appendHead (node) {\nlet firstNode = this.head.next\nthis.head.next = node\nnode.pre = this.head\nnode.next = firstNode\nfirstNode.pre = node\n};")]),e._v(" "),n("p",[e._v("function removeTail () {\nlet key = this.tail.pre.key\nthis.removeNode(this.tail.pre)\nreturn key\n};")]),e._v(" "),n("p",[e._v("作者：ZStar01\n链接：https://leetcode-cn.com/problems/lru-cache/solution/shuang-lian-biao-ha-xi-biao-by-zstar01/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);