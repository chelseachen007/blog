(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{443:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue-和-react-差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-差异"}},[t._v("#")]),t._v(" Vue 和 React 差异")]),t._v(" "),s("h2",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),s("h3",{attrs:{id:"编译时优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译时优化"}},[t._v("#")]),t._v(" 编译时优化")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("functinon "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("react")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("react")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("creatElement")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("因为 js 是一种运行时的动态语言，所以无法做编译时优化")]),t._v(" "),s("h3",{attrs:{id:"运行时优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行时优化"}},[t._v("#")]),t._v(" 运行时优化")]),t._v(" "),s("p",[t._v("触发渲染：this.setState,props,事件啊")]),t._v(" "),s("p",[t._v("触发后进行全局 DOM diff，所以将 DOM 树拆分成一个个 fiber")]),t._v(" "),s("ol",[s("li",[t._v("调度 选择优先级比较高的任务, 顶堆")]),t._v(" "),s("li",[t._v("协调 计算要执行的任务 -> 执行任务 计算系统空闲时间是否足够")]),t._v(" "),s("li",[t._v("提交 根据提交的内容修改 => render")])]),t._v(" "),s("h3",{attrs:{id:"react-v17"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-v17"}},[t._v("#")]),t._v(" React v17")]),t._v(" "),s("p",[t._v("在 React V17 中， React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中.也就是事件委托")]),t._v(" "),s("h2",{attrs:{id:"vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),s("p",[t._v("Vue 是模板代码")]),t._v(" "),s("p",[t._v("运行时编译（runtime）")]),t._v(" "),s("p",[t._v("Vue 的 template 模板只有自己的编译器才能编译")]),t._v(" "),s("h3",{attrs:{id:"编译时优化-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译时优化-2"}},[t._v("#")]),t._v(" 编译时优化")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("HTML 转化成 AST（抽象语法树）")]),t._v(" "),s("p",[t._v("使用了大量正则进行标签匹配，优化静态节点做上标记，提取 if，@，v-等方法")]),t._v(" "),s("p",[t._v("通过一个栈，进行标签拼接")])]),t._v(" "),s("li",[s("p",[t._v("options.optimize 进行静态节点优化")]),t._v(" "),s("p",[t._v("在静态节点标记 Ast static")]),t._v(" "),s("p",[t._v("静态节点创建提升 VNode __static__")])]),t._v(" "),s("li",[s("p",[t._v("优化后的 AST 转换成代码")])])]),t._v(" "),s("h3",{attrs:{id:"运行时优化-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行时优化-2"}},[t._v("#")]),t._v(" 运行时优化")]),t._v(" "),s("p",[t._v("vue 双向数据绑定")]),t._v(" "),s("p",[t._v("vue1 每一个动态数据对应一个 watcher 占用内存大")]),t._v(" "),s("p",[t._v("vue2 Watcher 是组件级的 => 所以需要 dom diff 也是组件级")]),t._v(" "),s("h2",{attrs:{id:"更新性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新性能"}},[t._v("#")]),t._v(" 更新性能")]),t._v(" "),s("p",[t._v("简单来说，在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。")]),t._v(" "),s("p",[t._v("当然我们可以使用 "),s("code",[t._v("PureComponent")]),t._v("，或是手动实现 "),s("code",[t._v("shouldComponentUpdate")]),t._v(" 方法，来规避不必要的渲染。")]),t._v(" "),s("p",[t._v("在 Vue 应用中，组件的依赖是在渲染过程中"),s("code",[t._v("自动追踪")]),t._v("的，因此系统能"),s("code",[t._v("精确知晓")]),t._v("哪个组件需要被重渲染。")]),t._v(" "),s("p",[t._v("从理论上看，Vue 的渲染更新机制"),s("code",[t._v("更加细粒度")]),t._v("，也更加"),s("code",[t._v("精确")]),t._v("。")])])}),[],!1,null,null,null);a.default=r.exports}}]);