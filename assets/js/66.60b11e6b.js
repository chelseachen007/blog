(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{437:function(v,_,a){"use strict";a.r(_);var t=a(42),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"初识操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初识操作系统"}},[v._v("#")]),v._v(" 初识操作系统")]),v._v(" "),a("h2",{attrs:{id:"计算机组成原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机组成原理"}},[v._v("#")]),v._v(" 计算机组成原理")]),v._v(" "),a("p",[v._v("这个问题是可计算的吗？")]),v._v(" "),a("p",[v._v("不可计算问题")]),v._v(" "),a("ul",[a("li",[v._v("无穷问题")]),v._v(" "),a("li",[v._v("停机问题")])]),v._v(" "),a("h2",{attrs:{id:"人工智能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#人工智能"}},[v._v("#")]),v._v(" 人工智能")]),v._v(" "),a("p",[v._v("此外，包括停机问题、包括 NP 问题在内的很多问题，虽然不能解决，但可以努力让计算机的解决方案超过人类的水平，这就是人工智能。")]),v._v(" "),a("h2",{attrs:{id:"冯诺依曼模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冯诺依曼模型"}},[v._v("#")]),v._v(" 冯诺依曼模型")]),v._v(" "),a("h4",{attrs:{id:"cpu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[v._v("#")]),v._v(" CPU")]),v._v(" "),a("p",[v._v("64位和32位的区别")]),v._v(" "),a("p",[v._v("在进行2^32次内的计算是没有区别的，但是进行2^64的数字时 32位就需要把拆成2个2^32来进行低位计算 然后再进位。")]),v._v(" "),a("h2",{attrs:{id:"不支持递归的程序语言如何实现递归程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不支持递归的程序语言如何实现递归程序"}},[v._v("#")]),v._v(" 不支持递归的程序语言如何实现递归程序？")]),v._v(" "),a("p",[v._v("计算机编程语言用"),a("strong",[v._v("栈")]),v._v("来实现递归函数。")]),v._v(" "),a("p",[v._v("栈的使用方法是不断往上堆数据，所以需要一个栈指针（Stack Pointer， SP）指向栈顶（也就是下一个可以写入的位置）。每次将数据写入栈时，就把数据写到栈指针指向的位置，然后将 SP 的值增加。")]),v._v(" "),a("p",[v._v("为了提高效率，我们通常会用一个特殊的寄存器来存储栈指针，这个寄存器就叫作 Stack Pointer，在大多数芯片中都有这个特殊的寄存器。一开始，SP 指向 0x100 位置，而 0x100 位置还没有数据。")]),v._v(" "),a("h2",{attrs:{id:"class的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class的实现"}},[v._v("#")]),v._v(" class的实现")]),v._v(" "),a("p",[v._v("首先一个 class 会分成两个部分，一部分是数据（也称作属性），另一部分是函数（也称作方法）。")]),v._v(" "),a("p",[v._v("class 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("如果遇到属性，就为属性分配内存地址；")])]),v._v(" "),a("li",[a("p",[v._v("如果遇到方法，方法本身需要存到正文段（也就是程序所在的内存区域），再将方法的值设置为方法指令所在的内存地址。")])])]),v._v(" "),a("p",[v._v("当我们调用一个 class 方法的时候，本质上是执行了一个函数，因此和函数调用是一致的：")]),v._v(" "),a("ol",[a("li",[v._v("首先把返回值和返回地址压栈；")]),v._v(" "),a("li",[v._v("然后压栈参数；")]),v._v(" "),a("li",[v._v("最后执行跳转。")])]),v._v(" "),a("p",[v._v("总结：")]),v._v(" "),a("ol",[a("li",[v._v("我们写的程序需要翻译成指令才能被执行，这个翻译工具叫作编译器。")]),v._v(" "),a("li",[v._v("平时你编程做的事情，用机器指令也能做，所以从计算能力上来说它们是等价的，最终这种计算能力又和图灵机是等价的。如果一个语言的能力和图灵机等价，我们就说这个语言是图灵完备的语言。现在市面上的绝大多数语言都是图灵完备的语言，但也有一些不是，比如 HTML、正则表达式和 SQL 等。")]),v._v(" "),a("li",[v._v("我们通过汇编语言构造高级程序；通过高级程序构造自己的业务逻辑，这些都是工程能力的一种体现。")])]),v._v(" "),a("h2",{attrs:{id:"ssd、内存和-l1-cache-相比速度差多少倍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssd、内存和-l1-cache-相比速度差多少倍"}},[v._v("#")]),v._v(" SSD、内存和 L1 Cache 相比速度差多少倍？")]),v._v(" "),a("p",[v._v("我们希望存储器速度快、体积小、空间大、能耗低、散热好、断电数据不丢失。但在现实中，我们往往无法把所有需求都实现。")]),v._v(" "),a("p",[v._v("下面我们举几个例子，带你深入体会一下，比如：")]),v._v(" "),a("ol",[a("li",[v._v("如果一个存储器的体积小，那它存储空间就会受到制约。")]),v._v(" "),a("li",[v._v("如果一个存储器电子元件密度很大，那散热就会有问题。因为电子元件都会产生热能，所以电子元件非常集中的 CPU，就需要单独的风扇或者水冷帮助电子元件降温。")]),v._v(" "),a("li",[v._v("如果一个存储器离 CPU 较远，那么在传输过程中必然会有延迟，因此传输速度也会下降。")])]),v._v(" "),a("h3",{attrs:{id:"存储器分级策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储器分级策略"}},[v._v("#")]),v._v(" 存储器分级策略")]),v._v(" "),a("p",[v._v("既然我们不能用一块存储器来解决所有的需求，那就必须把需求分级。")]),v._v(" "),a("p",[v._v("一种可行的方案，就是根据数据的使用频率使用不同的存储器：高频使用的数据，读写越快越好，因此用最贵的材料，放到离 CPU 最近的位置；使用频率越低的数据，我们放到离 CPU 越远的位置，用越便宜的材料。")]),v._v(" "),a("p",[v._v("具体来说，通常我们把存储器分成这么几个级别：")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("寄存器；")])]),v._v(" "),a("li",[a("p",[v._v("L1-Cache；")])]),v._v(" "),a("li",[a("p",[v._v("L2-Cache；")])]),v._v(" "),a("li",[a("p",[v._v("L3-Cahce；")])]),v._v(" "),a("li",[a("p",[v._v("内存；")]),v._v(" "),a("p",[v._v("内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多")]),v._v(" "),a("p",[v._v("内存速度大概在 200~300 个 CPU 周期之间。")])]),v._v(" "),a("li",[a("p",[v._v("硬盘/SSD。")]),v._v(" "),a("p",[v._v("SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。")])])]),v._v(" "),a("h3",{attrs:{id:"缓存的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存的算法"}},[v._v("#")]),v._v(" 缓存的算法")]),v._v(" "),a("h4",{attrs:{id:"方案1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案1"}},[v._v("#")]),v._v(" 方案1")]),v._v(" "),a("p",[v._v("CPU 读取到一个内存地址，我们就增加一个条目。当我们要查询一个内存地址的数据在不在 L1- 缓存中的时候，可以遍历每个条目，看条目中的内存地址是否和查询的内存地址相同。如果相同，我们就取出条目中缓存的值。")]),v._v(" "),a("p",[v._v("这个方法需要遍历缓存中的每个条目，因此计算速度会非常慢，")]),v._v(" "),a("h4",{attrs:{id:"方案2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案2"}},[v._v("#")]),v._v(" 方案2")]),v._v(" "),a("p",[v._v("这里，我们可以用一个数学的方法。比如有 1000 个内存地址，但只有 10 个缓存条目。内存地址的编号是 0、1、2、3，...，999，缓存条目的编号是 0~9。我们思考一个内存编号，比如 701，然后用数学方法把它映射到一个缓存条目，比如 701 整除 10，得到缓存条目 1。")]),v._v(" "),a("p",[v._v("用这种方法，我们每次拿到一个内存地址，都可以快速确定它的缓存条目；然后再比较缓存条目中的第一列内存地址和查询的内存地址是否相同，就可以确定内存地址有没有被缓存。")]),v._v(" "),a("p",[v._v("延伸一下，这里用到了一种类似哈希表的方法：地址 % 10，其实就构成了一个简单的哈希函数。")]),v._v(" "),a("h2",{attrs:{id:"linux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linux"}},[v._v("#")]),v._v(" Linux")]),v._v(" "),a("p",[a("code",[v._v("ls -F")]),v._v("就可以看到当前目录下的文件和它的类型。")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("*")]),v._v("结尾的是可执行文件；")]),v._v(" "),a("li",[a("code",[v._v("=")]),v._v("结尾的是 Socket 文件；")]),v._v(" "),a("li",[a("code",[v._v("@")]),v._v("结尾的是软链接；")]),v._v(" "),a("li",[a("code",[v._v("|")]),v._v("结尾的管道文件；")]),v._v(" "),a("li",[v._v("没有符号结尾的是普通文件；")]),v._v(" "),a("li",[a("code",[v._v("/")]),v._v("结尾的是目录。")])]),v._v(" "),a("h3",{attrs:{id:"文件的增删改查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件的增删改查"}},[v._v("#")]),v._v(" 文件的增删改查")]),v._v(" "),a("p",[a("code",[v._v("man touch")]),v._v(" manual 说明书")]),v._v(" "),a("p",[v._v("mkdir  新建目录")]),v._v(" "),a("p",[v._v("touch 新建文件")]),v._v(" "),a("p",[v._v("ls  查看文件目录")]),v._v(" "),a("p",[v._v("rm 删除目录 remove 缩写")]),v._v(" "),a("p",[v._v("cat  "),a("code",[v._v("cat /ect/hosts/")]),v._v(" 查阅")]),v._v(" "),a("h3",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),a("p",[v._v("应用的可执行文件是放在文件系统里，把可执行文件启动，就会在操作系统里（具体来说是内存中）形成一个应用的副本，这个副本就是进程。")]),v._v(" "),a("p",[v._v("ps  查看当前进程")]),v._v(" "),a("h2",{attrs:{id:"linux-内核和-windows-内核有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linux-内核和-windows-内核有什么区别"}},[v._v("#")]),v._v(" Linux 内核和 Windows 内核有什么区别？")]),v._v(" "),a("h3",{attrs:{id:"内核的能力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内核的能力"}},[v._v("#")]),v._v(" 内核的能力")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：")])]),v._v(" "),a("li",[a("p",[v._v("管理进程、线程（决定哪个进程、线程使用 CPU）")])]),v._v(" "),a("li",[a("p",[v._v("管理内存（决定内存用来做什么）；")])]),v._v(" "),a("li",[a("p",[v._v("连接硬件设备（为进程、和设备间提供通信能力）；")])]),v._v(" "),a("li",[a("p",[v._v("提供系统调用（接收进程发送来的系统调用）。")])])]),v._v(" "),a("h2",{attrs:{id:"gc回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gc回收算法"}},[v._v("#")]),v._v(" GC回收算法")]),v._v(" "),a("p",[v._v("吞吐量，暂停时间，使用空间三者不可兼得。")]),v._v(" "),a("p",[v._v("标记的过程主要分为 3 个步骤：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("如果对象在白色集合中，那么先将对象放入灰色集合；")])]),v._v(" "),a("li",[a("p",[v._v("然后遍历节点的所有的引用对象，并递归所有引用对象；")])]),v._v(" "),a("li",[a("p",[v._v("当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。")])])]),v._v(" "),a("h2",{attrs:{id:"计算机网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[v._v("#")]),v._v(" 计算机网络")]),v._v(" "),a("p",[v._v("每个课程都不够深入，这部分 去看")])])}),[],!1,null,null,null);_.default=s.exports}}]);