(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{421:function(v,_,t){"use strict";t.r(_);var e=t(45),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),t("p",[v._v("我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和繁改，通常我们把这种攻击方式称为"),t("strong",[v._v("中间人攻击")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"什么是-https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-https"}},[v._v("#")]),v._v(" 什么是 HTTPS")]),v._v(" "),t("p",[v._v("“明文”和“不安全”仅凭 HTTP 自身是无力解决的，需要引入新的 HTTPS 协议，从“"),t("strong",[v._v("HTTP over HTTP")]),v._v(" ”变成了“ "),t("strong",[v._v("HTTP over SSL/TLS")]),v._v("”，让 HTTP 运行在了安全的 SSL/TLS 协议上， 收发报文不再使用 Socket API，而是调用专门的安全接口。")]),v._v(" "),t("p",[v._v("通常我们认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是："),t("code",[v._v("机密性")]),v._v("、"),t("code",[v._v("完整性")]),v._v("，"),t("code",[v._v("身份认证")]),v._v("和"),t("code",[v._v("不可否认")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"https-和-http-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-和-http-有什么区别"}},[v._v("#")]),v._v(" HTTPS 和 HTTP 有什么区别")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("HTTPS")]),v._v(" 在 "),t("code",[v._v("TCP/IP")]),v._v(" 的基础上，增加了一层 "),t("code",[v._v("SLL/TCL")]),v._v(" 进行安全验证，使报文能够加密传输")]),v._v(" "),t("li",[t("code",[v._v("HTTP")]),v._v(" 建立简单，只需要经过三次握手即可进行报文传输，"),t("code",[v._v("HTTPS")]),v._v(" 在之后还需要进行 "),t("code",[v._v("SSL/TLS")]),v._v(" 握手")]),v._v(" "),t("li",[t("code",[v._v("HTTP")]),v._v(" 的端口号是 "),t("strong",[v._v("80")]),v._v(" ，"),t("code",[v._v("HTTPS")]),v._v(" 则是"),t("strong",[v._v("443")])]),v._v(" "),t("li",[v._v("HTTPS 需要向 CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的。")])]),v._v(" "),t("h2",{attrs:{id:"sll-tls-又是如何进行加密的呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sll-tls-又是如何进行加密的呢"}},[v._v("#")]),v._v(" SLL/TLS 又是如何进行加密的呢")]),v._v(" "),t("p",[v._v("加密是针对安全的 4 个特性进行的逐层加密。")]),v._v(" "),t("h3",{attrs:{id:"机密性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#机密性"}},[v._v("#")]),v._v(" 机密性")]),v._v(" "),t("p",[v._v("实现机密性最常用的手段就是"),t("strong",[v._v("加密")]),v._v("，就是把消息用某种方式转化成乱码。\n"),t("strong",[v._v("明文")]),v._v(" 通过 "),t("strong",[v._v("加密算法")]),v._v(" ==> "),t("strong",[v._v("密文")]),t("br"),v._v("\n使用 "),t("strong",[v._v("秘钥")]),v._v(" 还原 "),t("strong",[v._v("明文")]),v._v(" 的过程叫 "),t("strong",[v._v("解密")])]),v._v(" "),t("p",[v._v("按照秘钥的使用方式,可以分成两大类：对称加密和非对称机密;")]),v._v(" "),t("h4",{attrs:{id:"对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[v._v("#")]),v._v(" 对称加密")]),v._v(" "),t("p",[v._v("加密和解密使用的都是同一个秘钥。只要保证了秘钥的安全，整个通信过程就可以说具有机密性了")]),v._v(" "),t("p",[v._v("目前常用的对称加密算法只有 "),t("code",[v._v("AES")]),v._v(" 和 "),t("code",[v._v("ChaCha20")]),v._v("。")]),v._v(" "),t("h4",{attrs:{id:"加密分组模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加密分组模式"}},[v._v("#")]),v._v(" 加密分组模式")]),v._v(" "),t("p",[v._v("对称算法还有一个“"),t("strong",[v._v("分组模式")]),v._v("”的概念，它可以让算法用"),t("strong",[v._v("固定长度的密钥加密任意长度的明文")]),v._v("，把小秘密 （即密钥）转化为大秘密（即密文）。")]),v._v(" "),t("p",[v._v("最新的分组模式被称为 AEAD，在加密的同时增加了认证的功能，常用的是"),t("code",[v._v("GCM")]),v._v("、"),t("code",[v._v("CCM")]),v._v("和"),t("code",[v._v("Poly1305")]),v._v("。\n把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。\n举个栗子，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM；ChaCha20-Poly1305 的意思是 ChaCha20 算法，使用的分组模式是 Poly1305。")]),v._v(" "),t("h4",{attrs:{id:"非对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[v._v("#")]),v._v(" 非对称加密")]),v._v(" "),t("p",[v._v("在讲对称加密的时候也提到了，需要保证秘钥的安全。那么我们应该如何交换这个秘钥？")]),v._v(" "),t("p",[v._v("非对称加密，它有两个秘钥，"),t("strong",[v._v("公钥")]),v._v(" 和 "),t("strong",[v._v("私钥")]),v._v(" ，公钥可以公开给任何人使用，而私钥必须严格保密。\n非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文.")]),v._v(" "),t("p",[v._v("非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 "),t("code",[v._v("DH")]),v._v("、"),t("code",[v._v("DSA")]),v._v("、"),t("code",[v._v("RSA")]),v._v("、"),t("code",[v._v("ECC")]),v._v(" 等。")]),v._v(" "),t("ul",[t("li",[v._v("RSA：它的安全性基于“ "),t("strong",[v._v("整数分解")]),v._v(" ”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，")]),v._v(" "),t("li",[v._v("ECC：基于“ "),t("strong",[v._v("椭圆曲线离散对数")]),v._v(" ”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名")])]),v._v(" "),t("p",[v._v("比起 RSA，ECC 在安全强度和性能上都有明显的优势")]),v._v(" "),t("h4",{attrs:{id:"混合加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混合加密"}},[v._v("#")]),v._v(" 混合加密")]),v._v(" "),t("p",[v._v("非对称加密虽然实现了机密性，但因为基于数学难题，运算速度很慢，抛弃了速度,所以在 TLS 中采用了混合加密的方式。")]),v._v(" "),t("p",[v._v("混合加密方式：用随机数产生对称算法使用的“"),t("strong",[v._v("会话密钥")]),v._v(" ”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。然后对方拿到 “"),t("strong",[v._v("会话密钥")]),v._v(" ” 再用私钥解密，这就完成了对称秘钥交换。")]),v._v(" "),t("h3",{attrs:{id:"完整性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完整性"}},[v._v("#")]),v._v(" 完整性")]),v._v(" "),t("h4",{attrs:{id:"摘要算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要算法"}},[v._v("#")]),v._v(" 摘要算法")]),v._v(" "),t("p",[v._v("摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且 独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”，是一种单向的加密算法。")]),v._v(" "),t("p",[v._v("我们日常工作常用的"),t("code",[v._v("MD5")]),v._v("、"),t("code",[v._v("SHA-1")]),v._v("就是摘要算法")]),v._v(" "),t("p",[v._v("目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。")]),v._v(" "),t("h4",{attrs:{id:"完整性-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完整性-1"}},[v._v("#")]),v._v(" 完整性 1")]),v._v(" "),t("p",[v._v("摘要算法保证"),t("code",[v._v("数字摘要")]),v._v("和"),t("code",[v._v("原文")]),v._v("是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。\n如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。")]),v._v(" "),t("p",[v._v("但是，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密"),t("strong",[v._v("消息")]),v._v("和"),t("strong",[v._v("摘要")])]),v._v(" "),t("h3",{attrs:{id:"数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[v._v("#")]),v._v(" 数字签名")]),v._v(" "),t("p",[v._v("数字签名是为了解决通信两端的信任问题。\n它通过将非对称加密里的“"),t("strong",[v._v("私钥")]),v._v(" ”，使用私钥再加上摘要算法，就能够实现“"),t("strong",[v._v("数字签名")]),v._v("”，同时实现“"),t("strong",[v._v("身份认证")]),v._v("”和“"),t("strong",[v._v("不可否认")]),v._v("”。")]),v._v(" "),t("p",[v._v("签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后， 再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。")]),v._v(" "),t("h3",{attrs:{id:"数字证书和-ca"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字证书和-ca"}},[v._v("#")]),v._v(" 数字证书和 CA")]),v._v(" "),t("p",[t("strong",[v._v("CA")]),v._v(" （Certificate Authority，证书认证机构），具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造， 是可信的。")]),v._v(" "),t("p",[v._v("CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含"),t("code",[v._v("序列号")]),v._v("、 "),t("code",[v._v("用途")]),v._v("、"),t("code",[v._v("颁发者")]),v._v("、"),t("code",[v._v("有效时间")]),v._v("等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“"),t("strong",[v._v("数字证书")]),v._v("”（Certificate）。")]),v._v(" "),t("img",{attrs:{src:"https://i.loli.net/2021/03/02/1J3lEYdtGFgjuAq.png",alt:"CA"}}),v._v(" "),t("p",[v._v("小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 "),t("strong",[v._v("Root CA")]),v._v(" ，就只能自己证明 自己了，这个就叫“"),t("strong",[v._v("自签名证书")]),v._v(" ”（Self-Signed Certificate）或者“"),t("strong",[v._v("根证书")]),v._v(" ”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。")]),v._v(" "),t("p",[v._v("总结为以下三点：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("申请数字证书是"),t("strong",[v._v("不需要提供私钥")]),v._v("的，要确保私钥永远只能由服务器掌握；")])]),v._v(" "),t("li",[t("p",[v._v("数字证书最核心的是 CA 使用它的私钥生成的数字签名；")])]),v._v(" "),t("li",[t("p",[v._v("内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。")])])]),v._v(" "),t("h5",{attrs:{id:"证书体系的弱点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#证书体系的弱点"}},[v._v("#")]),v._v(" 证书体系的弱点")]),v._v(" "),t("p",[v._v("如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。\n还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。")]),v._v(" "),t("h5",{attrs:{id:"密码套件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#密码套件"}},[v._v("#")]),v._v(" 密码套件")]),v._v(" "),t("p",[v._v("TLS 的密码套件命名非常规范，格式很固定。基本的形式是“"),t("code",[v._v("密钥交换算法")]),v._v("+"),t("code",[v._v("签名算法")]),v._v("+"),t("code",[v._v("对称加密算法")]),v._v("+"),t("code",[v._v("分组模式")]),v._v(" +"),t("code",[v._v("摘要算法")])]),v._v(" "),t("p",[v._v("举个栗子:server suite : ECDHE-RSA-AES256-GCM-SHA384\nserver suite 意思是：“"),t("strong",[v._v("握手时使用 "),t("code",[v._v("ECDHE 算法")]),v._v("进行密钥交换，用 "),t("code",[v._v("RSA")]),v._v(" 签名和身份认证，握手后的通信使用 "),t("code",[v._v("AES")]),v._v(" 对称算法，密钥长度 256 位，分组模式是 "),t("code",[v._v("GCM")]),v._v("，摘要算法 "),t("code",[v._v("SHA384")]),v._v(" 用于消息认证和产生随机数。")]),v._v("”")]),v._v(" "),t("h2",{attrs:{id:"连接过程解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接过程解析"}},[v._v("#")]),v._v(" 连接过程解析")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/03/02/4hwLVxiHpsQ2YZC.png",alt:"image-20200918173057621"}})]),v._v(" "),t("h3",{attrs:{id:"tsl1-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tsl1-2"}},[v._v("#")]),v._v(" TSL1.2")]),v._v(" "),t("ol",[t("li",[v._v("TCP3 次握手")]),v._v(" "),t("li",[v._v("“"),t("strong",[v._v("Client Hello")]),v._v('" 里面有：客户端的 '),t("code",[v._v("版本号")]),v._v("、"),t("code",[v._v("支持的密码套件")]),v._v("，"),t("code",[v._v("随机数（Client Random)")])]),v._v(" "),t("li",[v._v('"'),t("strong",[v._v("Server Hello")]),v._v('" ,对版本号，选择一个密码套件，返回一个 '),t("code",[v._v("随机数（Server Random）")])]),v._v(" "),t("li",[v._v('"'),t("strong",[v._v("Server Certificate")]),v._v('" 把证书也发给了客户端。')]),v._v(" "),t("li",[v._v('"'),t("strong",[v._v("Server Key Exchange")]),v._v('" ,发送 '),t("code",[v._v("公钥（Server Params）")]),v._v("和"),t("code",[v._v("私钥签名认证")])]),v._v(" "),t("li",[v._v('"'),t("strong",[v._v("Server Hello Done")]),v._v(' " 服务器表示信息发完了')])]),v._v(" "),t("p",[v._v("这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息："),t("code",[v._v("Client Random")]),v._v("、"),t("code",[v._v("Server Random")]),v._v(" 和 "),t("code",[v._v("Server Params")])]),v._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[v._v('"'),t("strong",[v._v("Client Key Exchange")]),v._v('" 发送 '),t("code",[v._v("公钥（Client Params）")])])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Change Cipher Spec")])])]),v._v(" "),t("p",[v._v("客户端和服务器将 "),t("code",[v._v("公钥（Server Params）")]),v._v(" 和 "),t("code",[v._v("公钥（Client Params）")]),v._v("使用 "),t("strong",[v._v("ECDHE 算法")]),v._v("一阵算，算出一个新的随机数 “"),t("strong",[v._v("Pre-Master")]),v._v("，")]),v._v(" "),t("p",[v._v("再使用"),t("code",[v._v("Client Random")]),v._v("、"),t("code",[v._v("Server Random")]),v._v(" 和"),t("code",[v._v("Pre-Master")]),v._v("生成用于加密会话的主密钥“"),t("strong",[v._v("Master Secret")]),v._v("”")]),v._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[v._v("Client “"),t("strong",[v._v("Change Cipher Spec")]),v._v("”，计算出主秘钥")]),v._v(" "),t("li",[v._v("Client “**Finished **” 把之前所有发送的数据做个摘要，再加密一下，等待服务器验证")]),v._v(" "),t("li",[v._v("Server “"),t("strong",[v._v("Change Cipher Spec")]),v._v("”，计算出主秘钥")]),v._v(" "),t("li",[v._v("Server “**Finished **” 双方都验证加密解密 OK，握手正式结束")])]),v._v(" "),t("h3",{attrs:{id:"tsl1-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tsl1-3"}},[v._v("#")]),v._v(" TSL1.3")]),v._v(" "),t("p",[v._v("因为密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了。TLS1.3 压缩了以前 的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。")]),v._v(" "),t("ul",[t("li",[v._v("首先浏览器向服务端发送 "),t("strong",[v._v("Client -random")]),v._v("、 "),t("strong",[v._v("可使用的对称密码套件和非对称加密套件")]),v._v("、")]),v._v(" "),t("li",[v._v("服务器端保存 Client-random，并返回 "),t("strong",[v._v("server-random")]),v._v("、"),t("strong",[v._v("选择的密码套件")]),v._v("、"),t("strong",[v._v("公钥")]),v._v("(这里加上 CA 发送的是数字证书)、"),t("strong",[v._v("密钥交换算法的公钥")]),v._v("("),t("strong",[v._v("Server Params")]),v._v(")")]),v._v(" "),t("li",[v._v("浏览器拿到数据后，也生成一个"),t("strong",[v._v("Client Param")]),v._v(" ,对 "),t("strong",[v._v("Client -random")]),v._v(" 和 "),t("strong",[v._v("server-random")]),v._v(" "),t("strong",[v._v(",Server Params")]),v._v(","),t("strong",[v._v("Client Params")]),v._v("使用 "),t("strong",[v._v("ECDHE 算法")]),v._v(" 生成 "),t("strong",[v._v("Pre-master")]),v._v("，并使用"),t("strong",[v._v("公钥加密")]),v._v("发送给服务器")])]),v._v(" "),t("p",[v._v("pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了")]),v._v(" "),t("ul",[t("li",[v._v("服务器收到后，使用私钥解密并验证合法性，至此，两边就都可以通过 "),t("strong",[v._v("cilent-random")]),v._v(" 和 "),t("strong",[v._v("server-random")]),v._v(" 、 "),t("strong",[v._v("Pre-master")]),v._v(" 三个共同随机数生成"),t("strong",[v._v("对称秘钥")]),v._v("("),t("strong",[v._v("Master Secret")]),v._v(")进行加密传输了")])]),v._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[v._v("master_secret "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[v._v("PRF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("\n  pre_master_secret"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"master\tsecret"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  ClientHello"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("random "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),v._v(" ServerHello"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("random\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),t("p",[v._v("这里的“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，")]),v._v(" "),t("h2",{attrs:{id:"双向认证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向认证"}},[v._v("#")]),v._v(" 双向认证")]),v._v(" "),t("p",[v._v("上面说的是“单向认证 单向认证”握手过程，只认证了服务器的身份，而没有认证客户端的身份。这是因为通常 单向认证通过后已经建立了安全通信，用账号、密码等简单的手段就能够确认用户的真实身份。")]),v._v(" "),t("p",[v._v("但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“ "),t("strong",[v._v("双向认证")]),v._v("”，这样会更加安全。\n双向认证的流程也没有太多变化，只是在“"),t("strong",[v._v("Server Hello Done")]),v._v(" ”之后，“"),t("strong",[v._v("Client Key Exchange Client")]),v._v("”之前，客户端要发送“ "),t("strong",[v._v("Client Certificate")]),v._v("”消息，服务器收到后也把证书链走一遍，验证客户端的身份。")]),v._v(" "),t("h2",{attrs:{id:"常见问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[v._v("#")]),v._v(" 常见问题")]),v._v(" "),t("h4",{attrs:{id:"客户端如何验证证书的合法性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端如何验证证书的合法性"}},[v._v("#")]),v._v(" 客户端如何验证证书的合法性")]),v._v(" "),t("p",[v._v("操作系统和浏览器等在安装时候就预装了 CA(证书机构)列表，服务商在使用 https 前，会向 CA 请求颁发签名，在建立 https 连接的时候，浏览器会查看证书签名颁发机构是否在 CA 列表，如果是表示可以信任。")]),v._v(" "),t("p",[v._v("具体是，服务端生成密钥对(k1,k2)， 将实体信息以及 k1 发送给 CA，获取证书，CA 对签名内容 hash 生成消息摘要，CA 用自己私钥 k2-CA 对消息摘要加密，生成签名，浏览器在校验时，获取到相应 CA 的公钥（预装），对签名解密，获取消息摘要，同时通过相同的 hash 函数对证书消息 hash 生成摘要，两者对比，如果相同则信任")]),v._v(" "),t("h4",{attrs:{id:"为什么要证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要证书"}},[v._v("#")]),v._v(" 为什么要证书")]),v._v(" "),t("p",[v._v("客户端和服务端会使用双方的公钥生成一个随机数"),t("strong",[v._v("Pre-Master")]),v._v("，然后再使用三个随机数生成传输使用的主密钥，如果中间人冒充，对两边的公钥进行伪造，则后面的加密都将无效，而 CA 就用于保证，你获得的公钥确实是你要访问的可靠网站的公钥，而不是别人冒充的。")]),v._v(" "),t("h4",{attrs:{id:"http-传输消息都是明文的-黑客完全可以作为中间人劫持消息-再利用-ecdhe-算法-这样不就能破解密钥了吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-传输消息都是明文的-黑客完全可以作为中间人劫持消息-再利用-ecdhe-算法-这样不就能破解密钥了吗"}},[v._v("#")]),v._v(" HTTP 传输消息都是明文的，黑客完全可以作为中间人劫持消息，再利用 ECDHE 算法，这样不就能破解密钥了吗？")]),v._v(" "),t("p",[v._v("ECDHE 算法利用了椭圆曲线和离散对数等思想，按照当下的计算机算力，很难在短时间进行破解。且每次握手时生成的都是一对临时的公钥和私钥，这样就保证每次的密钥对也不同。")]),v._v(" "),t("p",[v._v("即使大费力气破解了一次的密钥，之前的历史消息也不会受到影响，保证了前向安全。")]),v._v(" "),t("h4",{attrs:{id:"为什么要是三个随机数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要是三个随机数"}},[v._v("#")]),v._v(" 为什么要是三个随机数")]),v._v(" "),t("p",[v._v("TLS 的设计者不信任客户端或服务器伪随机数的可靠性，为了保证真正 的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让 黑客难以猜测。")]),v._v(" "),t("hr"),v._v(" "),t("p",[t("a",{attrs:{href:"https://time.geekbang.org/column/intro/100029001",target:"_blank",rel:"noopener noreferrer"}},[v._v("《透视 HTTP 协议》"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.notion.so/https-0f8409f5e5324b1ea59139cc773c0c3b",target:"_blank",rel:"noopener noreferrer"}},[v._v("《feiker 的 https 笔记》"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzU2MzM2NzU0NA==&mid=2247485331&idx=1&sn=3290686db857491af5bf1afc4ff5e516&chksm=fc5a1c84cb2d959275f6e6358905f712abe2c7564e08d7b8458c10586541242660f347afa915&mpshare=1&scene=1&srcid=&sharer_sharetime=1590368862394&sharer_shareid=156d5dbafdee46be3487cf570e2c5b5f&key=86794a6e80bbe8028320b404246a03249c7490bf30f4b3e5fd60624c6f17619e7b289ce5a28d714e92b9575e3019f287116f947faa9ac01a1391b39679887386068bda0d8c93413f97fedb135ee843ad&ascene=1&uin=MTIwOTc2NTAyMQ%3D%3D&devicetype=Windows+10+x64&version=6209007b&lang=zh_CN&exportkey=AZVguo6IOZ4Lo9Jnqu%2BZh%2F4%3D&pass_ticket=MJmGQMNd0o3fOqvJiPVouOXMm4%2FEWRnv7HGmY%2FVXMFPp9YPPHNWzl7zIBwMwJkKj",target:"_blank",rel:"noopener noreferrer"}},[v._v("《硬核！30 张图解 HTTP 常见的面试题》"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/22142170",target:"_blank",rel:"noopener noreferrer"}},[v._v("《深入揭秘 HTTPS》"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.im/post/5c441073e51d455226654d60#heading-8",target:"_blank",rel:"noopener noreferrer"}},[v._v("《完全图解 HTTPS》"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);