(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{570:function(t,a,e){"use strict";e.r(a);var r=e(45),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),e("h2",{attrs:{id:"设置index或者random为key会产生的后果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设置index或者random为key会产生的后果"}},[t._v("#")]),t._v(" 设置index或者random为key会产生的后果")]),t._v(" "),e("p",[t._v("首先index为key，在sameNode阶段都会判定是同一个节点，然后进行patchNode，发现内容变化后，进行class，style等的更新，而其实原本只需要进行Vnode的交换")]),t._v(" "),e("p",[t._v("使用random则会是sameNode 判断完全失效，全部节点重新销毁，重建，性能损坏很大")]),t._v(" "),e("h2",{attrs:{id:"组件中的-data-为什么是函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件中的-data-为什么是函数"}},[t._v("#")]),t._v(" 组件中的 data 为什么是函数")]),t._v(" "),e("p",[t._v("如果组件里 data 直接写了一个对象的话，那么如果你在模板中多次声明这个组件，组件中的 data 会指向同一个引用。")]),t._v(" "),e("p",[t._v("此时如果在某个组件中对 data 进行修改，会导致其他组件里的 data 也被污染。而如果使用函数的话，每个组件里的 data 会有单独的引用，这个问题就可以避免了。")]),t._v(" "),e("h2",{attrs:{id:"watch-中的-deep-true-是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-中的-deep-true-是如何实现的"}},[t._v("#")]),t._v(" Watch 中的 deep:true 是如何实现的")]),t._v(" "),e("p",[t._v("当你设置deep：true的时候，源码内部会对对象进行递归访问，在此过程中不断的进行依赖收集。但这种情况会增加大量的依赖收集的性能上的损耗，可以通过watch指定字符串的方式减少。")]),t._v(" "),e("h2",{attrs:{id:"nexttick-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-实现原理"}},[t._v("#")]),t._v(" nextTick 实现原理")]),t._v(" "),e("p",[t._v("nextTick 通过去检测兼容性，遵循优先使用微任务的原则进行降级，分别是promise.then => mutationObserver = > setImmediate => setTimeout。")]),t._v(" "),e("p",[t._v("在nextTick接收到fn的时候，将其push到一个队列中，到下个任务队列时进行统一的执行清空")]),t._v(" "),e("h2",{attrs:{id:"请说一下响应式数据的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请说一下响应式数据的原理"}},[t._v("#")]),t._v(" 请说一下响应式数据的原理")])])}),[],!1,null,null,null);a.default=s.exports}}]);