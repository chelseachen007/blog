(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{414:function(t,s,a){"use strict";a.r(s);var e=a(45),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("如果做完这个笔记，还需要回头看原文，那么讲毫无意义。")])]),t._v(" "),a("h1",{attrs:{id:"深入浅出搞定react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出搞定react"}},[t._v("#")]),t._v(" 深入浅出搞定React")]),t._v(" "),a("h2",{attrs:{id:"常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),a("p",[t._v("React的声明周期，对比15 16的区别")]),t._v(" "),a("p",[t._v("diff算法以及实现")]),t._v(" "),a("p",[t._v("React是什么样的框架，和Vue的对比")]),t._v(" "),a("p",[t._v("React的介绍以及原理实现")]),t._v(" "),a("h2",{attrs:{id:"基础知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[t._v("#")]),t._v(" 基础知识")]),t._v(" "),a("h3",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("JSX 的本质是什么，它和 JS 之间到底是什么关系？")])]),t._v(" "),a("li",[a("p",[t._v("为什么要用 JSX？不用会有什么后果？")])]),t._v(" "),a("li",[a("p",[t._v("JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？")])])]),t._v(" "),a("p",[t._v("Facebook 公司给 JSX 的定位是 JavaScript 的“扩展”，他在js编译后，会变成React.createElement，这个编译过程使用的就是 "),a("code",[t._v("Babel")])]),t._v(" "),a("p",[t._v("JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BeuGAepNsAACqreYXrj0410.png",alt:"Drawing 3.png"}})]),t._v(" "),a("p",[a("strong",[t._v("在实际的面试场景下，许多候选人由于缺乏对源码的了解，谈及 createElement 时总会倾向于去夸大它的“工作量”")]),t._v("。但其实，相信你也已经发现了，createElement 中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的"),a("strong",[t._v("每一个步骤几乎都是在格式化数据")]),t._v("。")]),t._v(" "),a("p",[t._v("可以联想到字节码和机器码之间的转换")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/5C/74/CgqCHl-Bex6AM5rhAACJMrix5bk913.png",alt:"Drawing 7.png"}})]),t._v(" "),a("p",[t._v("ReactElement 就是我们常说的虚拟DOM, 他和真实DOM之间还有个 "),a("strong",[t._v("ReactDOM")]),t._v(".render()")]),t._v(" "),a("h2",{attrs:{id:"react-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期"}},[t._v("#")]),t._v(" React 生命周期")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// React 15")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillReceiveProps")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillUnmount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/5E/31/Ciqc1F-GZbGAGNcBAAE775qohj8453.png",alt:"1.png"}})]),t._v(" "),a("p",[t._v("组件的更新分为两种：一种是由父组件更新触发的更新；另一种是组件自身调用自己的 setState 触发的更新。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的")]),t._v("，这个结论，请你谨记。")])]),t._v(" "),a("h3",{attrs:{id:"react-16-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-16-3"}},[t._v("#")]),t._v(" React 16.3")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/5D/D9/CgqCHl-FVVeAaMJvAAKXOyLlUwM592.png",alt:"Drawing 0.png"}})]),t._v(" "),a("p",[t._v("React 15 生命周期和 React 16.3 生命周期在挂载阶段的主要差异在于，"),a("strong",[t._v("废弃了 componentWillMount，新增了 getDerivedStateFromProps")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate")])]),t._v(" "),a("p",[t._v("区别在于 "),a("strong",[t._v("getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate")]),t._v("。"),a("strong",[t._v("它的执行时机是在 render 方法之后，真实 DOM 更新之前")]),t._v("。在这个阶段里，我们可以"),a("strong",[t._v("同时获取到更新前的真实 DOM 和更新前后的 state&props 信息")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”（引用自 React 官网）。")])]),t._v(" "),a("h4",{attrs:{id:"为什么要去除掉-componentwillupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要去除掉-componentwillupdate"}},[t._v("#")]),t._v(" 为什么要去除掉 componentWillUpdate")]),t._v(" "),a("p",[t._v("因为react 15是同步进行渲染，同步渲染的递归栈是非常深的，而且不能打断，这样就很容易一直占据着主线程，直到递归结束释放主线程**。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互**的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。")]),t._v(" "),a("p",[t._v("在 Fiber 机制下，"),a("strong",[t._v("render 阶段是允许暂停、终止和重启的")]),t._v("。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。"),a("strong",[t._v("这就导致 render 阶段的生命周期都是有可能被重复执行的")]),t._v("。")]),t._v(" "),a("p",[t._v("我们再来看看 React 16 打算废弃的是哪些生命周期：")]),t._v(" "),a("ul",[a("li",[t._v("componentWillMount；")]),t._v(" "),a("li",[t._v("componentWillUpdate；")]),t._v(" "),a("li",[t._v("componentWillReceiveProps。")])]),t._v(" "),a("p",[t._v("这些生命周期的共性，"),a("strong",[t._v("就是它们都处于 render 阶段，都可能重复被执行")]),t._v("，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html%C3%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 团队给出的这篇文章"),a("OutboundLink")],1),t._v(" 就帮助大家规避“误操作”来说是绰绰有余的。")]),t._v(" "),a("h2",{attrs:{id:"react-数据通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-数据通信"}},[t._v("#")]),t._v(" React 数据通信")]),t._v(" "),a("p",[t._v("所谓"),a("strong",[t._v("单向数据流")]),t._v("，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。")]),t._v(" "),a("ul",[a("li",[t._v("父 - 子 props")]),t._v(" "),a("li",[t._v("子 - 父  传递方法")]),t._v(" "),a("li",[t._v("兄弟组件  通过连接同一个属性值 进行并且传递方法")]),t._v(" "),a("li",[t._v("跨层级  事件中心 发布中心")])]),t._v(" "),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" Context")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" AppContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createContext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Provider"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Consumer "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" AppContext\n\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Provider")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Provider value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("title"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" content"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("content"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Title "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Content "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Provider"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Consumer")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Consumer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Consumer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("h3",{attrs:{id:"过时的context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过时的context"}},[t._v("#")]),t._v(" 过时的Context")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("代码不够优雅")])]),t._v(" "),a("li",[t._v("如果组件提供的一个Context发生了变化，而中间父组件的 shouldComponentUpdate 返回 false，"),a("strong",[t._v("那么使用到该值的后代组件不会进行更新")]),t._v("。使用了 Context 的组件则完全失控，所以基本上没有办法能够可靠的更新 Context。"),a("a",{attrs:{href:"https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇博客文章"),a("OutboundLink")],1),t._v("很好地解释了为何会出现此类问题，以及你该如何规避它。  ——React 官方")])]),t._v(" "),a("h3",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),a("h2",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" Hooks")]),t._v(" "),a("p",[t._v("React-Hooks 自 "),a("strong",[t._v("React 16.8 以来")]),t._v("才真正被推而广之")]),t._v(" "),a("h3",{attrs:{id:"函数组件与类组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数组件与类组件"}},[t._v("#")]),t._v(" 函数组件与类组件")]),t._v(" "),a("p",[t._v("函数组件与类组件的对比：无关“优劣”，只谈“不同”")]),t._v(" "),a("ul",[a("li",[t._v("类组件需要继承 class，函数组件不需要；")]),t._v(" "),a("li",[t._v("类组件可以访问生命周期方法，函数组件不能；")]),t._v(" "),a("li",[t._v("类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；")]),t._v(" "),a("li",[t._v("类组件中可以定义并维护 state（状态），而函数组件不可以；")]),t._v(" "),a("li",[t._v("......")])]),t._v(" "),a("h3",{attrs:{id:"类组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类组件"}},[t._v("#")]),t._v(" 类组件")]),t._v(" "),a("p",[t._v("React 类组件内部预置了相当多的“现成的东西”等着你去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，你只需要轻轻地"),a("strong",[t._v("继承")]),t._v("一个 React.Component 即可。")]),t._v(" "),a("p",[a("strong",[t._v("但是 多就是好吗")])]),t._v(" "),a("p",[t._v("他增加了我们的学习成本，这时就显得类组件太重了。")]),t._v(" "),a("h3",{attrs:{id:"函数组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[t._v("#")]),t._v(" 函数组件")]),t._v(" "),a("p",[t._v("，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。这些要素毫无疑问是重要的，它们也确实驱动着 React 团队做出改变。但是除此之外，还有一个非常容易被大家忽视、也极少有人能真正理解到的知识点，我在这里要着重讲一下。这个知识点缘起于 React 作者 Dan 早期特意为类组件和函数组件写过的"),a("a",{attrs:{href:"https://overreacted.io/how-are-function-components-different-from-classes/",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇非常棒的对比文章"),a("OutboundLink")],1),t._v("，这篇文章很长，但是通篇都在论证这一句话：")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("函数组件会捕获 render 内部的状态，这是两类组件最大的不同。")])])]),t._v(" "),a("p",[a("strong",[t._v("函数组件更加契合 React 框架的设计理念")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("UI = render(data)")])]),t._v(" "),a("h3",{attrs:{id:"为什么需要-react-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-react-hooks"}},[t._v("#")]),t._v(" 为什么需要 React-Hooks”")]),t._v(" "),a("ol",[a("li",[a("h4",{attrs:{id:"告别难以理解的-class-把握-class-的两大-痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#告别难以理解的-class-把握-class-的两大-痛点"}},[t._v("#")]),t._v(" 告别难以理解的 Class：把握 Class 的两大“痛点”")]),t._v(" "),a("p",[a("strong",[t._v("this 和生命周期")]),t._v("两个痛点")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"hooks-如何实现更好的逻辑拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks-如何实现更好的逻辑拆分"}},[t._v("#")]),t._v(" Hooks 如何实现更好的逻辑拆分")]),t._v(" "),a("p",[t._v("**"),a("em",[t._v("*我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们*"),a("em",[t._v("实现业务逻辑的聚合，避免复杂的组件和冗余的代码")])]),t._v("。")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"状态复用-hooks-将复杂的问题变简单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态复用-hooks-将复杂的问题变简单"}},[t._v("#")]),t._v(" 状态复用：Hooks 将复杂的问题变简单")])])]),t._v(" "),a("h3",{attrs:{id:"使用原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用原则"}},[t._v("#")]),t._v(" 使用原则")]),t._v(" "),a("p",[t._v("使用原则，原则的内容如下：")]),t._v(" "),a("ol",[a("li",[t._v("只在 React 函数中调用 Hook；")]),t._v(" "),a("li",[t._v("不要在循环、条件或嵌套函数中调用 Hook。")])]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[a("strong",[t._v("从源码调用流程看原理：Hooks 的正常运作，在底层依赖于顺序链表")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mountWorkInProgressHook")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意，单个 hook 是以对象的形式存在的")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" hook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    memoizedState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    baseState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    baseQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    queue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgressHook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理")]),t._v("\n    firstWorkInProgressHook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgressHook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" hook"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 若链表不为空，则将 hook 追加到链表尾部")]),t._v("\n    workInProgressHook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgressHook"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" hook"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回当前的 hook")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" workInProgressHook"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("到这里可以看出，"),a("strong",[t._v("hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("h3",{attrs:{id:"发展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发展"}},[t._v("#")]),t._v(" 发展")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("原生 JS 支配下的“人肉 DOM” 时期")])]),t._v(" "),a("li",[a("p",[t._v("解放生产力的先导阶段：jQuery 时期")]),t._v(" "),a("p",[t._v("对DOM API进行封装")])]),t._v(" "),a("li",[a("p",[t._v("民智初启：早期模板引擎方案")]),t._v(" "),a("p",[t._v("它更新 DOM 的方式是将已经渲染出 DOM 整体注销后再整体重渲染，并且不存在更新缓冲这一说。所以有性能上的问题")])]),t._v(" "),a("li",[a("p",[t._v("全自动:虚拟DOM")]),t._v(" "),a("p",[a("strong",[t._v("虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能")]),t._v("。")]),t._v(" "),a("p",[t._v("误区：虚拟DOM性能上具有优势，"),a("strong",[t._v("虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级")]),t._v("。但是在实际使用中，频繁的setState这种修改少量信息的情况下，虚拟DOM具有性能上的优势。")])])]),t._v(" "),a("h3",{attrs:{id:"价值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#价值"}},[t._v("#")]),t._v(" 价值")]),t._v(" "),a("p",[t._v("虚拟 DOM 解决的关键问题有以下两个。")]),t._v(" "),a("ol",[a("li",[t._v("研发体验/研发效率的问题")]),t._v(" "),a("li",[t._v("跨平台的问题")])]),t._v(" "),a("h3",{attrs:{id:"栈调和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈调和"}},[t._v("#")]),t._v(" 栈调和")]),t._v(" "),a("p",[a("strong",[t._v("Diff 确实是调和过程中最具代表性的一环")]),t._v("，但是 "),a("strong",[a("code",[t._v("调和 !== Diff")])])]),t._v(" "),a("h2",{attrs:{id:"setstate-是同步还是异步的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate-是同步还是异步的"}},[t._v("#")]),t._v(" setState 是同步还是异步的")]),t._v(" "),a("p",[t._v("结论："),a("strong",[t._v("并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的")])]),t._v(" "),a("h3",{attrs:{id:"主流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主流程"}},[t._v("#")]),t._v(" 主流程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image2/M01/04/81/Cip5yF_yswuAWzDfAAEc1lISh-Q211.png",alt:"3.png"}})]),t._v(" "),a("h3",{attrs:{id:"锁结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁结构"}},[t._v("#")]),t._v(" 锁结构")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("reduce")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进来先锁上")]),t._v("\n  isBatchingUpdates "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'reduce setState前的count'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      count"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'reduce setState后的count'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行完函数再放开")]),t._v("\n  isBatchingUpdates "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("咱们开头锁上的那个 isBatchingUpdates，对 setTimeout 内部的执行逻辑完全没有约束力。因为 isBatchingUpdates 是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为了 false，这就使得当前场景下的 setState 具备了立刻发起同步更新的能力。所以咱们前面说的没错——"),a("strong",[t._v("setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),a("p",[t._v("React 团队在用户体验方面最为要紧的一个追求。 "),a("strong",[t._v("快速响应")])]),t._v(" "),a("p",[a("strong",[t._v("实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验")])]),t._v(" "),a("p",[t._v("React 16 前，"),a("strong",[t._v("Reconciler(找不同)")]),t._v(" => "),a("strong",[t._v("Renderer(渲染不同)")]),t._v(" ，从 Reconciler 到 Renderer 这个过程是严格同步的。")]),t._v(" "),a("p",[t._v("React 16以后，增加了一层 Scheduler（调度器），首先，"),a("strong",[t._v("每个更新任务都会被赋予一个优先级")]),t._v("。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被"),a("strong",[t._v("中断")]),t._v("，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 "),a("strong",[t._v("A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);s.default=n.exports}}]);